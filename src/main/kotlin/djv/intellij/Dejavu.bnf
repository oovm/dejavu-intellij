{
    parserClass = "djv.intellij.language.parser.DjvParser"
    parserUtilClass = "com.intellij.lang.parser.GeneratedParserUtilBase"

    psiClassPrefix = "Djv"
    psiImplClassSuffix = "Node"
    psiPackage = "djv.intellij.language.psi"
    psiImplPackage = "djv.intellij.language.psi_node"

    elementTypeHolderClass = "djv.intellij.language.psi.DjvTypes"
    elementTypeClass = "djv.intellij.language.psi.DjvElementType"
    tokenTypeClass = "djv.intellij.language.psi.DjvElementType"

    extends = "com.intellij.extapi.psi.ASTWrapperPsiElement"
    psiImplUtilClass = "djv.intellij.language.psi_node.DjvPsiExtension"

    tokens = [
        AS = "as"

        PARENTHESIS_L = '('
        PARENTHESIS_R = ')'
        BRACKET_L = '['
        BRACKET_R = ']'
        BRACE_L = '{'
        BRACE_R = '}'
        ACCENT = '^'
        ANGLE_L = '<'
        ANGLE_R = '>'
        QUOTATION = '"'
        ESCAPE = '\'
        TAGGED = '<-'
        TO = '->'

        SOFT_CONNECT = '~'
        CHOOSE='|'

        EQ = '='
        SAHA_TEXT = "<TEXT>"
        SLOT_START = '{%'
        SLOT_END = '%}'
        KW_IF = "if"
        KW_ELSE_IF = 'else-if'
        KW_ELSE = 'else'
        KW_END_IF = 'end-if'
        KW_FOR = 'for'
        KW_END_FOR = 'end-for'
        COLON = ':'
        SEMICOLON = ';'
        COMMA = ','
        DOLLAR = '$'
        DOT = '.'
        AT = '@'
        HYPHEN = '-'
        NOT='!'
        OPTIONAL='?'
        MANY1 = '+'
        MANY = '*'
    ]
}

DejaVu ::= statements*;
// fake used for mixin
// pri used for syntax highlight
fake comment_doc ::= COMMENT_DOC;
private comment ::= COMMENT_LINE | COMMENT_BLOCK | COMMENT_DOC;

private statements ::=
      slot_expression
    | slot_for_statement
    | slot_if_statement
    | text_statement
    ;
// ---------------------------------------------------------------------------------------------------------------------
// text is these who not surrounded by `{%   %}`
text_statement ::= SAHA_TEXT+;
// ---------------------------------------------------------------------------------------------------------------------
slot_use ::= KW_USE;
// ---------------------------------------------------------------------------------------------------------------------
slot_for_statement ::= slot_for_start statements* slot_for_else? slot_for_end {
    pin = slot_for_start
};
slot_for_else  ::= slot_else statements* {
    pin = slot_else
};

slot_for_start ::= slot_l KW_FOR pattern kw_in expr slot_r;
slot_for_end   ::= slot_l (KW_END_FOR|KW_END) slot_r;
// ---------------------------------------------------------------------------------------------------------------------
inline_for_statement ::= KW_FOR pattern kw_in expr '{' '}' [inline_else] {

};
kw_in          ::= "in";
// ---------------------------------------------------------------------------------------------------------------------
slot_if_statement ::= slot_if_start statements* slot_else_if* slot_if_else? slot_if_end {
    pin = slot_if_start
};
slot_else_if  ::= slot_else_if_start statements* {
    pin = slot_else_if_start
};
slot_if_else  ::= slot_else statements* {
    pin = slot_else
};

slot_if_start ::= slot_l KW_IF expr slot_r;
slot_else_if_start ::= slot_l KW_ELSE_IF expr slot_r;
slot_else ::= slot_l KW_ELSE slot_r;
slot_if_end   ::= slot_l (KW_END_IF|KW_END) slot_r;
// ---------------------------------------------------------------------------------------------------------------------
inline_if_statement ::= KW_IF expr '{' '}' [inline_else] {

};
inline_else ::= KW_ELSE '{' '}' {

};
// ---------------------------------------------------------------------------------------------------------------------
inline_let_statement ::= KW_LET pattern '=' expr {

};
// ---------------------------------------------------------------------------------------------------------------------
pattern ::= identifier (COMMA identifier)*;
// ---------------------------------------------------------------------------------------------------------------------
// {% slot %}
slot_expression ::= slot_l (inline_normal SEMICOLON?)* inlined_end? slot_r {

};
private inline_normal ::=
    inline_let_statement
    ;
private inlined_end ::=
    inline_for_statement |
    inline_if_statement |
    expr
    ;
slot_l ::= SLOT_START;
slot_r ::= SLOT_END;
// ---------------------------------------------------------------------------------------------------------------------
expr ::= term (infix term)*;
term ::= (prefix)* atom suffix*
atom ::= '(' expr ')' | function_call | value;
infix ::= ADD | SUB | MUL | DIV | MOD | EQ | NE;
prefix ::= ADD;
// ---------------------------------------------------------------------------------------------------------------------
suffix ::= op_suffix | dot_call;
op_suffix ::= OPTIONAL;
dot_call ::= DOT identifier [function_args];
// ---------------------------------------------------------------------------------------------------------------------
// @function("path")
function_call ::= identifier function_args;
function_args ::= PARENTHESIS_L [expr (COMMA expr)* [COMMA]] PARENTHESIS_R;
// ---------------------------------------------------------------------------------------------------------------------
macro_call  ::= HASH identifier;
// ---------------------------------------------------------------------------------------------------------------------
value ::= KW_SPECIAL | num | string_literal | table | namespace;
type_hint ::= identifier;
number_suffix ::= identifier;
// ---------------------------------------------------------------------------------------------------------------------
pair ::= symbol_path eq value;
symbol_path ::= key (DOT key)*
key ::= string_literal | key_symbol | INTEGER;
private eq ::= EQ | COLON;
key_symbol ::= SYMBOL;
// ---------------------------------------------------------------------------------------------------------------------
private num ::= [SIGN] (INTEGER | DECIMAL) [number_suffix] | [SIGN] BYTE;
// ---------------------------------------------------------------------------------------------------------------------
string_literal ::= esc | STRING_SQ char* STRING_SQ | STRING_DQ char* STRING_DQ;
private char ::= CHARACTER | esc;
private esc ::= ESCAPE_UNICODE | ESCAPE_SPECIAL;
// ---------------------------------------------------------------------------------------------------------------------
table ::= [type_hint] <<paired table_inner>>;
private table_inner ::= [table_item (COMMA table_item)* [COMMA]];
private table_item ::= pair | value;
// ---------------------------------------------------------------------------------------------------------------------
object ::= BRACE_L (object_item [COMMA|SEMICOLON])* BRACE_R
object_item ::= object_key COLON value;
object_key ::= identifier | string_literal;
// ---------------------------------------------------------------------------------------------------------------------
modifiers ::= (identifier !('('|'{'|ARROW|':'))*;
namespace ::= identifier (DOUBLE_COLON identifier)*
identifier ::= SYMBOL {
    mixin = "djv.intellij.language.mixin.MixinIdentifier"
}
// ---------------------------------------------------------------------------------------------------------------------
meta parenthesis ::= PARENTHESIS_L [<<item>> (<<delimiter>> <<item>>)* [<<delimiter>>]] PARENTHESIS_R;

private meta paired ::=
    PARENTHESIS_L <<param>> PARENTHESIS_R
  | BRACKET_L <<param>> BRACKET_R
  | BRACE_L <<param>> BRACE_R
